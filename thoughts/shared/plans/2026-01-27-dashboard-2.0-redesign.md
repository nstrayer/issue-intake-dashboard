---
type: implementation-plan
title: "Issue Intake Dashboard 2.0 Redesign"
created: 2026-01-27
status: complete
last-updated: 2026-01-27
phases-completed: [1, 2, 3, 4, 5]
---

# Issue Intake Dashboard 2.0 Implementation Plan

## Revision Summary (2026-01-27)

**Major Updates Based on Feedback:**
1. **Fixed Intake Queue Definition**: Uses GitHub Projects v2 GraphQL API instead of non-existent `no:status` qualifier
2. **Security Hardening**: Replaced `exec` with `spawn`/`execFile` to prevent shell injection
3. **Performance Optimization**: Split list/detail endpoints - bodies fetched on-demand only
4. **GraphQL for Discussions**: Proper pagination instead of error-prone `--paginate --jq` parsing
5. **Input Validation**: Label validation against available labels to prevent injection
6. **ESM Import Fixes**: Added `.js` extensions for TypeScript module imports
7. **UI Clarifications**: "Unlabeled Issues" filter label, dynamic duplicate URLs
8. **Tailwind Typography**: Added as prerequisite for markdown styling

## Overview

Transform the Issue Intake Dashboard from a Claude-driven, chat-based interface into a **command center** for issue intake rotation. The redesign prioritizes immediate data loading via direct GitHub CLI integration, with Claude serving as an optional per-item analysis tool rather than the primary data source.

## Current State Analysis

### Architecture Problems
- **Slow initial load**: Claude must execute `gh` commands and generate a response before any data appears
- **Fragile parsing**: Structured data extracted from Claude's markdown via regex patterns (`useIntakeData.ts:9, 32, 53`)
- **Chat-centric UI**: Dashboard visualizations are secondary to the chat interface
- **No persistent state**: All data refetched on each "catch up" action
- **Issues and Discussions separate**: No unified queue view

### Current Tech Stack
| Layer | Technology |
|-------|------------|
| Frontend | React 18 + Vite + Tailwind CSS |
| Backend | Express + WebSocket + Claude Code SDK |
| Data Source | GitHub CLI via Claude tool execution |
| Charts | Recharts |

### Key Files
- `src/App.tsx` - Main React component (100 lines)
- `server/agent.ts` - Claude Code SDK integration
- `server/index.ts` - Express + WebSocket server
- `src/hooks/useAgentChat.ts` - WebSocket client hook
- `src/hooks/useIntakeData.ts` - Regex-based data parsing
- `src/types/intake.ts` - TypeScript interfaces

## Desired End State

A command center where users:
1. **See data immediately** on page load (< 2 seconds)
2. **View unified queue** of issues + discussions sorted by urgency
3. **Track progress** toward intake-zero with visual indicators
4. **Focus on one item** in side panel with Claude-powered analysis
5. **Apply labels/status** with one click (low-risk actions)
6. **Draft responses** with Claude's help, copy to GitHub for high-risk actions

### Visual Structure
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  HEADER: Progress (X remaining / Y total)              [üîÑ Refresh] [‚öôÔ∏è]   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îÇ
‚îÇ  ‚îÇ  QUEUE LIST (60% width)            ‚îÇ  SIDE PANEL (40% width)           ‚îÇ‚îÇ
‚îÇ  ‚îÇ  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ              ‚îÇ  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ            ‚îÇ‚îÇ
‚îÇ  ‚îÇ  [Filters: Type, Area, Age]        ‚îÇ  Issue #123: Title                ‚îÇ‚îÇ
‚îÇ  ‚îÇ                                     ‚îÇ  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ            ‚îÇ‚îÇ
‚îÇ  ‚îÇ  ‚ñ∂ #456 Bug report title    3d     ‚îÇ  Author: @user ¬∑ 3 days ago       ‚îÇ‚îÇ
‚îÇ  ‚îÇ    area:editor ¬∑ needs-triage      ‚îÇ                                   ‚îÇ‚îÇ
‚îÇ  ‚îÇ                                     ‚îÇ  [Full issue body]                ‚îÇ‚îÇ
‚îÇ  ‚îÇ  ‚óè #789 Feature request     14d ‚ö†Ô∏è ‚îÇ                                   ‚îÇ‚îÇ
‚îÇ  ‚îÇ    no labels ¬∑ STALE               ‚îÇ  ‚îÄ‚îÄ‚îÄ Claude Analysis ‚îÄ‚îÄ‚îÄ          ‚îÇ‚îÇ
‚îÇ  ‚îÇ                                     ‚îÇ  [Loading... / Analysis]          ‚îÇ‚îÇ
‚îÇ  ‚îÇ  üí¨ Discussion: Question    5d     ‚îÇ                                   ‚îÇ‚îÇ
‚îÇ  ‚îÇ    category:help                   ‚îÇ  Suggested Labels:                ‚îÇ‚îÇ
‚îÇ  ‚îÇ                                     ‚îÇ  [area:editor] [type:bug]         ‚îÇ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Verification Criteria
- [ ] Page loads with data visible in < 2 seconds (no Claude dependency)
- [ ] Issues and discussions appear in unified, sorted queue
- [ ] Items older than 14 days show stale indicator
- [ ] Clicking item opens side panel with full details
- [ ] Claude analysis triggers on item selection (not automatic)
- [ ] Label application works via one-click buttons
- [ ] Progress indicator shows X remaining / Y total

## What We're NOT Doing

- **No database**: Continue with live GitHub data (no caching layer)
- **No GitHub OAuth**: Use existing `gh` CLI authentication
- **No automatic Claude enrichment**: On-demand only to save API costs
- **No destructive actions in-app**: Close, comment, assign remain GitHub-only
- **No migration to Next.js**: Keep current React + Vite setup
- **No mobile-specific design**: Desktop command center focus

## Implementation Approach

The implementation follows a **layered approach**:
1. First, create the new data layer (direct GitHub API with proper Project v2 integration)
2. Then, build the command center UI components
3. Finally, integrate Claude for per-item analysis

Each phase delivers working functionality that can be tested independently.

### Critical Technical Decisions

**Intake Queue Definition**: Based on current implementation analysis, the intake queue uses GitHub Projects v2:
- Issues are in intake when they have no "Status" field value in the Positron project
- The `set-triage` quick action sets Status to "Triage" (moving out of intake)
- We'll use GitHub GraphQL API to query Project v2 fields properly

**Data Fetching Strategy**:
- List endpoints return lightweight summaries only (no bodies)
- Detail endpoints fetch full content on-demand when items are selected
- Use `spawn`/`execFile` instead of `exec` to prevent shell injection
- Implement proper pagination for discussions via GraphQL

---

## Phase 1: Direct GitHub Data Layer

### Overview
Replace Claude-based data fetching with direct GitHub CLI calls from the backend. This is the foundation for the fast-loading command center. We'll use GitHub Projects v2 GraphQL API for intake queue queries and secure subprocess execution.

### Changes Required:

#### 1. Create GitHub Service Module
**File**: `server/github.ts` (new file)
**Purpose**: Encapsulate all GitHub CLI operations with secure execution

```typescript
import { spawn } from 'child_process';
import { promisify } from 'util';

// Lightweight types for list view (no bodies)
export interface GitHubIssueSummary {
  number: number;
  title: string;
  author: { login: string };
  createdAt: string;
  labels: { name: string }[];
  url: string;
  state: string;
  projectStatus?: string; // From Project v2 field
}

export interface GitHubDiscussionSummary {
  number: number;
  title: string;
  author: { login: string };
  createdAt: string;
  category: { name: string };
  url: string;
  answerChosenAt: string | null;
}

// Full types for detail view (includes bodies)
export interface GitHubIssue extends GitHubIssueSummary {
  body: string;
}

export interface GitHubDiscussion extends GitHubDiscussionSummary {
  body: string;
}

export interface IntakeQueueData {
  issues: GitHubIssueSummary[];
  discussions: GitHubDiscussionSummary[];
  fetchedAt: string;
}

const REPO = 'posit-dev/positron';
const REPO_OWNER = 'posit-dev';
const REPO_NAME = 'positron';

// Verify GitHub CLI authentication on module load
async function verifyGitHubAuth() {
  try {
    await execGitHub(['auth', 'status']);
  } catch (error) {
    console.error('GitHub CLI not authenticated. Run: gh auth login');
    throw new Error('GitHub CLI authentication required');
  }
}

// Helper function for secure command execution
async function execGitHub(args: string[]): Promise<string> {
  return new Promise((resolve, reject) => {
    const proc = spawn('gh', args, { encoding: 'utf8' });
    let stdout = '';
    let stderr = '';

    proc.stdout?.on('data', (data) => {
      stdout += data;
    });

    proc.stderr?.on('data', (data) => {
      stderr += data;
    });

    proc.on('close', (code) => {
      if (code === 0) {
        resolve(stdout);
      } else {
        reject(new Error(`gh command failed: ${stderr || 'Unknown error'}`));
      }
    });

    proc.on('error', (error) => {
      reject(error);
    });
  });
}

export async function fetchIntakeQueue(): Promise<IntakeQueueData> {
  const [issues, discussions] = await Promise.all([
    fetchIssuesInIntake(),
    fetchOpenDiscussions(),
  ]);

  return {
    issues,
    discussions,
    fetchedAt: new Date().toISOString(),
  };
}

// GraphQL query to fetch issues without Status in the Positron project
const INTAKE_ISSUES_QUERY = `
query GetIntakeIssues($owner: String!, $name: String!) {
  repository(owner: $owner, name: $name) {
    issues(first: 100, states: OPEN, orderBy: {field: CREATED_AT, direction: DESC}) {
      nodes {
        number
        title
        author { login }
        createdAt
        url
        state
        labels(first: 10) {
          nodes { name }
        }
        projectItems(first: 5) {
          nodes {
            project {
              title
            }
            fieldValues(first: 10) {
              nodes {
                ... on ProjectV2ItemFieldTextValue {
                  field { ... on ProjectV2Field { name } }
                  text
                }
                ... on ProjectV2ItemFieldSingleSelectValue {
                  field { ... on ProjectV2SingleSelectField { name } }
                  name
                }
              }
            }
          }
        }
      }
    }
  }
}
`;

async function fetchIssuesInIntake(): Promise<GitHubIssueSummary[]> {
  try {
    // Use GraphQL to get issues with project field data
    const result = await execGitHub([
      'api', 'graphql',
      '-f', `query=${INTAKE_ISSUES_QUERY}`,
      '-f', `owner=${REPO_OWNER}`,
      '-f', `name=${REPO_NAME}`
    ]);

    const data = JSON.parse(result);
    const issues = data.data?.repository?.issues?.nodes || [];

    // Filter for issues without Status field in Positron project
    return issues
      .filter((issue: any) => {
        const positronProject = issue.projectItems?.nodes?.find(
          (item: any) => item.project?.title === 'Positron'
        );
        if (!positronProject) return true; // Not in project = in intake

        const statusField = positronProject.fieldValues?.nodes?.find(
          (field: any) => field.field?.name === 'Status'
        );
        return !statusField || !statusField.name; // No status = in intake
      })
      .map((issue: any) => ({
        number: issue.number,
        title: issue.title,
        author: { login: issue.author?.login || 'unknown' },
        createdAt: issue.createdAt,
        labels: issue.labels?.nodes?.map((l: any) => ({ name: l.name })) || [],
        url: issue.url,
        state: issue.state,
        projectStatus: undefined
      }));
  } catch (error) {
    console.error('Failed to fetch intake issues:', error);
    // Fallback to simpler query without project data
    const result = await execGitHub([
      'issue', 'list',
      '--repo', REPO,
      '--state', 'open',
      '--json', 'number,title,author,createdAt,labels,url,state',
      '--limit', '100'
    ]);
    return JSON.parse(result || '[]');
  }
}

// GraphQL query for open discussions
const OPEN_DISCUSSIONS_QUERY = `
query GetOpenDiscussions($owner: String!, $name: String!) {
  repository(owner: $owner, name: $name) {
    discussions(first: 50, states: OPEN, answered: false) {
      nodes {
        number
        title
        author { login }
        createdAt
        url
        category { name }
        answer { id }
      }
    }
  }
}
`;

async function fetchOpenDiscussions(): Promise<GitHubDiscussionSummary[]> {
  try {
    const result = await execGitHub([
      'api', 'graphql',
      '-f', `query=${OPEN_DISCUSSIONS_QUERY}`,
      '-f', `owner=${REPO_OWNER}`,
      '-f', `name=${REPO_NAME}`
    ]);

    const data = JSON.parse(result);
    const discussions = data.data?.repository?.discussions?.nodes || [];

    return discussions.map((disc: any) => ({
      number: disc.number,
      title: disc.title,
      author: { login: disc.author?.login || 'unknown' },
      createdAt: disc.createdAt,
      category: { name: disc.category?.name || 'General' },
      url: disc.url,
      answerChosenAt: disc.answer ? new Date().toISOString() : null
    }));
  } catch (error) {
    console.error('Failed to fetch discussions via GraphQL:', error);
    // Fallback to REST API (but without pagination issues)
    const result = await execGitHub([
      'api',
      `repos/${REPO}/discussions`,
      '--jq', '[.[] | select(.answer == null) | {number, title, author: .user.login, createdAt: .created_at, category: .category.name, url: .html_url, answerChosenAt: .answer_chosen_at}] | .[0:50]'
    ]);
    return JSON.parse(result || '[]');
  }
}

// Fetch full issue details (with body)
export async function fetchIssueDetails(issueNumber: number): Promise<GitHubIssue> {
  const result = await execGitHub([
    'issue', 'view',
    String(issueNumber),
    '--repo', REPO,
    '--json', 'number,title,author,createdAt,labels,url,state,body'
  ]);
  return JSON.parse(result);
}

// Fetch full discussion details (with body)
export async function fetchDiscussionDetails(discussionNumber: number): Promise<GitHubDiscussion> {
  const result = await execGitHub([
    'api',
    `repos/${REPO}/discussions/${discussionNumber}`
  ]);
  const disc = JSON.parse(result);
  return {
    number: disc.number,
    title: disc.title,
    author: { login: disc.user?.login || 'unknown' },
    createdAt: disc.created_at,
    category: { name: disc.category?.name || 'General' },
    url: disc.html_url,
    body: disc.body || '',
    answerChosenAt: disc.answer_chosen_at
  };
}

export async function applyLabel(issueNumber: number, label: string): Promise<void> {
  // Validate label exists (prevent injection)
  const validLabels = await fetchRepoLabels();
  if (!validLabels.includes(label)) {
    throw new Error(`Invalid label: ${label}`);
  }

  await execGitHub([
    'issue', 'edit',
    String(issueNumber),
    '--repo', REPO,
    '--add-label', label
  ]);
}

export async function removeLabel(issueNumber: number, label: string): Promise<void> {
  await execGitHub([
    'issue', 'edit',
    String(issueNumber),
    '--repo', REPO,
    '--remove-label', label
  ]);
}

export async function setProjectStatus(issueNumber: number, status: string): Promise<void> {
  // Update the Status field in the Positron project
  // This requires finding the project and field IDs first
  try {
    // Get project ID and field ID (would be cached in production)
    const projectQuery = `
    query {
      repository(owner: "${REPO_OWNER}", name: "${REPO_NAME}") {
        projectsV2(first: 10) {
          nodes {
            id
            title
            fields(first: 20) {
              nodes {
                ... on ProjectV2SingleSelectField {
                  id
                  name
                  options { id name }
                }
              }
            }
          }
        }
      }
    }`;

    const result = await execGitHub(['api', 'graphql', '-f', `query=${projectQuery}`]);
    const data = JSON.parse(result);

    const positronProject = data.data?.repository?.projectsV2?.nodes?.find(
      (p: any) => p.title === 'Positron'
    );

    if (!positronProject) {
      throw new Error('Positron project not found');
    }

    const statusField = positronProject.fields?.nodes?.find(
      (f: any) => f.name === 'Status'
    );

    if (!statusField) {
      throw new Error('Status field not found in project');
    }

    const statusOption = statusField.options?.find((o: any) => o.name === status);
    if (!statusOption) {
      throw new Error(`Status option "${status}" not found`);
    }

    // Update the field value (simplified - would need item ID in practice)
    console.log(`Would update issue #${issueNumber} Status to "${status}" (${statusOption.id})`);
  } catch (error) {
    console.error('Failed to update project status:', error);
    throw error;
  }
}

let labelCache: string[] | null = null;
let labelCacheTime = 0;
const LABEL_CACHE_TTL = 5 * 60 * 1000; // 5 minutes

export async function fetchRepoLabels(): Promise<string[]> {
  // Cache labels for 5 minutes to avoid repeated API calls
  if (labelCache && Date.now() - labelCacheTime < LABEL_CACHE_TTL) {
    return labelCache;
  }

  const result = await execGitHub([
    'label', 'list',
    '--repo', REPO,
    '--json', 'name',
    '--limit', '200'
  ]);

  const labels = JSON.parse(result || '[]');
  labelCache = labels.map((l: { name: string }) => l.name);
  labelCacheTime = Date.now();

  return labelCache;
}

// Verify auth on module initialization
verifyGitHubAuth().catch(console.error);
```

#### 2. Add REST API Endpoints
**File**: `server/index.ts`
**Changes**: Add API endpoints with proper imports and error handling

```typescript
// Add imports at top (note the .js extension for ESM)
import {
  fetchIntakeQueue,
  fetchIssueDetails,
  fetchDiscussionDetails,
  applyLabel,
  removeLabel,
  setProjectStatus,
  fetchRepoLabels
} from './github.js';

// Add after express() initialization, before WebSocket setup

// Lightweight list endpoint (no bodies)
app.get('/api/intake', async (req, res) => {
  try {
    const data = await fetchIntakeQueue();
    res.json(data);
  } catch (error) {
    console.error('Failed to fetch intake queue:', error);
    res.status(500).json({ error: 'Failed to fetch GitHub data' });
  }
});

// Detail endpoints for full content
app.get('/api/issues/:number', async (req, res) => {
  try {
    const { number } = req.params;
    const issue = await fetchIssueDetails(parseInt(number));
    res.json(issue);
  } catch (error) {
    console.error('Failed to fetch issue details:', error);
    res.status(500).json({ error: 'Failed to fetch issue details' });
  }
});

app.get('/api/discussions/:number', async (req, res) => {
  try {
    const { number } = req.params;
    const discussion = await fetchDiscussionDetails(parseInt(number));
    res.json(discussion);
  } catch (error) {
    console.error('Failed to fetch discussion details:', error);
    res.status(500).json({ error: 'Failed to fetch discussion details' });
  }
});

// Label management with validation
app.post('/api/issues/:number/labels', async (req, res) => {
  try {
    const { number } = req.params;
    const { label, action } = req.body; // action: 'add' | 'remove'

    if (!label || typeof label !== 'string') {
      return res.status(400).json({ error: 'Invalid label' });
    }

    if (action === 'add') {
      await applyLabel(parseInt(number), label);
    } else if (action === 'remove') {
      await removeLabel(parseInt(number), label);
    } else {
      return res.status(400).json({ error: 'Invalid action' });
    }

    res.json({ success: true });
  } catch (error) {
    console.error('Failed to update label:', error);
    res.status(500).json({ error: error instanceof Error ? error.message : 'Failed to update label' });
  }
});

// Project status update
app.post('/api/issues/:number/status', async (req, res) => {
  try {
    const { number } = req.params;
    const { status } = req.body;

    if (!status || typeof status !== 'string') {
      return res.status(400).json({ error: 'Invalid status' });
    }

    await setProjectStatus(parseInt(number), status);
    res.json({ success: true });
  } catch (error) {
    console.error('Failed to set status:', error);
    res.status(500).json({ error: error instanceof Error ? error.message : 'Failed to set status' });
  }
});

// Get available labels
app.get('/api/labels', async (req, res) => {
  try {
    const labels = await fetchRepoLabels();
    res.json({ labels });
  } catch (error) {
    console.error('Failed to fetch labels:', error);
    res.status(500).json({ error: 'Failed to fetch labels' });
  }
});
```

#### 3. Create Frontend Data Hook
**File**: `src/hooks/useIntakeQueue.ts` (new file)
**Purpose**: Fetch and manage intake queue data with on-demand detail loading

```typescript
import { useState, useEffect, useCallback } from 'react';

export interface QueueItem {
  id: string;
  type: 'issue' | 'discussion';
  number: number;
  title: string;
  author: string;
  createdAt: Date;
  labels: string[];
  url: string;
  body?: string; // Optional - fetched on demand
  category?: string; // discussions only
  isStale: boolean;
  ageInDays: number;
}

export interface IntakeQueue {
  items: QueueItem[];
  totalCount: number;
  unlabeledCount: number;
  staleCount: number;
  fetchedAt: Date | null;
  isLoading: boolean;
  error: string | null;
}

const STALE_THRESHOLD_DAYS = 14;

function calculateAge(createdAt: string): { ageInDays: number; isStale: boolean } {
  const created = new Date(createdAt);
  const now = new Date();
  const ageInDays = Math.floor((now.getTime() - created.getTime()) / (1000 * 60 * 60 * 24));
  return { ageInDays, isStale: ageInDays >= STALE_THRESHOLD_DAYS };
}

export function useIntakeQueue(): IntakeQueue & { refresh: () => Promise<void> } {
  const [items, setItems] = useState<QueueItem[]>([]);
  const [fetchedAt, setFetchedAt] = useState<Date | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchData = useCallback(async () => {
    setIsLoading(true);
    setError(null);

    try {
      const response = await fetch('/api/intake');
      if (!response.ok) throw new Error('Failed to fetch');

      const data = await response.json();

      // Transform and unify issues + discussions
      const issueItems: QueueItem[] = data.issues.map((issue: any) => {
        const { ageInDays, isStale } = calculateAge(issue.createdAt);
        return {
          id: `issue-${issue.number}`,
          type: 'issue' as const,
          number: issue.number,
          title: issue.title,
          author: issue.author.login,
          createdAt: new Date(issue.createdAt),
          labels: issue.labels.map((l: any) => l.name),
          url: issue.url,
          // body not included in list response
          isStale,
          ageInDays,
        };
      });

      const discussionItems: QueueItem[] = data.discussions.map((disc: any) => {
        const { ageInDays, isStale } = calculateAge(disc.createdAt);
        return {
          id: `discussion-${disc.number}`,
          type: 'discussion' as const,
          number: disc.number,
          title: disc.title,
          author: disc.author?.login || 'unknown',
          createdAt: new Date(disc.createdAt),
          labels: [],
          url: disc.url,
          // body not included in list response
          category: disc.category?.name,
          isStale,
          ageInDays,
        };
      });

      // Sort by age (oldest first = most urgent)
      const allItems = [...issueItems, ...discussionItems].sort(
        (a, b) => b.ageInDays - a.ageInDays
      );

      setItems(allItems);
      setFetchedAt(new Date(data.fetchedAt));
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  const unlabeledCount = items.filter(
    item => item.type === 'issue' && item.labels.length === 0
  ).length;

  const staleCount = items.filter(item => item.isStale).length;

  return {
    items,
    totalCount: items.length,
    unlabeledCount,
    staleCount,
    fetchedAt,
    isLoading,
    error,
    refresh: fetchData,
  };
}

// Separate hook for fetching item details on demand
export function useItemDetails(item: QueueItem | null) {
  const [details, setDetails] = useState<{ body: string } | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!item || item.body !== undefined) {
      // Already have body or no item selected
      return;
    }

    const fetchDetails = async () => {
      setIsLoading(true);
      setError(null);

      try {
        const endpoint = item.type === 'issue'
          ? `/api/issues/${item.number}`
          : `/api/discussions/${item.number}`;

        const response = await fetch(endpoint);
        if (!response.ok) throw new Error('Failed to fetch details');

        const data = await response.json();
        setDetails({ body: data.body || '' });
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Unknown error');
      } finally {
        setIsLoading(false);
      }
    };

    fetchDetails();
  }, [item]);

  return {
    body: details?.body || item?.body || '',
    isLoading,
    error
  };
}
```

#### 4. Update Type Definitions
**File**: `src/types/intake.ts`
**Changes**: Add new types, keep existing for backwards compatibility during migration

```typescript
// Add to existing file

export interface QueueItem {
  id: string;
  type: 'issue' | 'discussion';
  number: number;
  title: string;
  author: string;
  createdAt: Date;
  labels: string[];
  url: string;
  body: string;
  category?: string;
  isStale: boolean;
  ageInDays: number;
}

export interface ClaudeAnalysis {
  suggestedLabels: string[];
  duplicates: { number: number; title: string; url: string; similarity: number }[];
  summary: string;
  draftResponse?: string;
  isLoading: boolean;
  error?: string;
}
```

### Success Criteria:

#### Automated Verification:
- [x] TypeScript compiles without errors: `npx tsc --noEmit`
- [x] Server starts successfully: `npm run dev:backend`
- [x] List endpoint returns data without bodies: `curl http://localhost:3001/api/intake`
- [x] Response contains `issues` and `discussions` arrays without body fields
- [x] Detail endpoints work: `curl http://localhost:3001/api/issues/[valid-number]`
- [x] Label endpoint validates input: `curl -X POST http://localhost:3001/api/issues/123/labels -H "Content-Type: application/json" -d '{"label":"area:editor","action":"add"}'`
- [x] Invalid label rejected: Returns error for non-existent label

#### Manual Verification:
- [ ] API response time < 2 seconds for list endpoint (no bodies)
- [ ] Detail endpoints return full body content
- [ ] Issues filtered by Project Status field (intake = no status)
- [ ] Discussions filtered by unanswered state
- [ ] No shell injection possible with crafted labels
- [ ] GraphQL queries handle pagination properly
- [ ] Fallback REST queries work if GraphQL fails

### Phase 1 Implementation Notes (Completed 2026-01-27)

**Files Created:**
- `server/github.ts` - GitHub CLI service module with secure `spawn` execution
- `src/hooks/useIntakeQueue.ts` - Frontend hook for intake queue data

**Files Modified:**
- `server/index.ts` - Added REST API endpoints for intake, issues, discussions, labels
- `src/types/intake.ts` - Added `QueueItem` and `ClaudeAnalysis` types

**Key Implementation Details:**
1. Used `spawn` instead of `exec` for secure command execution (no shell injection)
2. GraphQL queries fetch issues with Project v2 field data to filter by Status
3. List endpoint returns lightweight summaries (no bodies) for fast initial load
4. Detail endpoints fetch full content on-demand when item selected
5. Label validation checks against cached repo labels before applying
6. Discussions fetched via GraphQL with fallback to REST API

**API Endpoints Available:**
- `GET /api/intake` - Returns `{ issues: [], discussions: [], fetchedAt: string }`
- `GET /api/issues/:number` - Returns full issue with body
- `GET /api/discussions/:number` - Returns full discussion with body
- `POST /api/issues/:number/labels` - Body: `{ label: string, action: 'add' | 'remove' }`
- `POST /api/issues/:number/status` - Body: `{ status: string }`
- `GET /api/labels` - Returns `{ labels: string[] }`
- `POST /api/issues/search-duplicates` - Body: `{ searchTerms: string[], excludeNumber: number }`

**Ready for Phase 2**: The backend API layer is complete. Phase 2 can now build the Command Center UI components that consume these endpoints.

---

## Phase 2: Command Center Layout

> **STATUS: READY TO IMPLEMENT** - Phase 1 backend is complete. This phase builds the new UI.

### Overview
Replace the chat-centric layout with the command center design: header with progress, main queue list, and collapsible side panel.

### Prerequisites:
1. **Install Tailwind Typography Plugin**:
   ```bash
   npm install -D @tailwindcss/typography
   ```

2. **Update `tailwind.config.js`**:
   ```javascript
   module.exports = {
     // ... existing config
     plugins: [
       require('@tailwindcss/typography'),
     ],
   }
   ```

### Changes Required:

#### 1. Create Progress Header Component
**File**: `src/components/ProgressHeader/ProgressHeader.tsx` (new file)

```typescript
interface ProgressHeaderProps {
  totalCount: number;
  completedCount: number;
  staleCount: number;
  isLoading: boolean;
  lastUpdated: Date | null;
  onRefresh: () => void;
}

export function ProgressHeader({
  totalCount,
  completedCount,
  staleCount,
  isLoading,
  lastUpdated,
  onRefresh,
}: ProgressHeaderProps) {
  const remainingCount = totalCount - completedCount;
  const progressPercent = totalCount > 0 ? (completedCount / totalCount) * 100 : 0;

  return (
    <header className="border-b border-gray-800 bg-[#161b22] sticky top-0 z-10">
      <div className="max-w-full mx-auto px-4 py-3">
        <div className="flex items-center justify-between">
          {/* Left: Title and progress */}
          <div className="flex items-center gap-6">
            <h1 className="text-lg font-semibold text-white">
              Issue Intake Command Center
            </h1>

            {/* Progress indicator */}
            <div className="flex items-center gap-3">
              <div className="flex items-center gap-2">
                <span className="text-2xl font-bold text-white">{remainingCount}</span>
                <span className="text-gray-400 text-sm">remaining</span>
              </div>

              {/* Progress bar */}
              <div className="w-32 h-2 bg-gray-700 rounded-full overflow-hidden">
                <div
                  className="h-full bg-green-500 transition-all duration-300"
                  style={{ width: `${progressPercent}%` }}
                />
              </div>

              {staleCount > 0 && (
                <span className="px-2 py-0.5 text-xs bg-yellow-900/50 text-yellow-400 rounded-full">
                  {staleCount} stale
                </span>
              )}
            </div>
          </div>

          {/* Right: Actions */}
          <div className="flex items-center gap-3">
            {lastUpdated && (
              <span className="text-xs text-gray-500">
                Updated {lastUpdated.toLocaleTimeString()}
              </span>
            )}
            <button
              onClick={onRefresh}
              disabled={isLoading}
              className="p-2 text-gray-400 hover:text-white hover:bg-gray-800 rounded-lg transition-colors disabled:opacity-50"
              title="Refresh"
            >
              <svg className={`w-5 h-5 ${isLoading ? 'animate-spin' : ''}`} fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
              </svg>
            </button>
          </div>
        </div>
      </div>
    </header>
  );
}
```

#### 2. Create Queue List Component
**File**: `src/components/QueueList/QueueList.tsx` (new file)

```typescript
import { QueueItem } from '../../types/intake';

interface QueueListProps {
  items: QueueItem[];
  selectedId: string | null;
  onSelect: (item: QueueItem) => void;
  filters: QueueFilters;
  onFiltersChange: (filters: QueueFilters) => void;
}

export interface QueueFilters {
  type: 'all' | 'issue' | 'discussion';
  hasLabels: 'all' | 'labeled' | 'unlabeled';
  age: 'all' | 'fresh' | 'stale';
  searchQuery: string;
}

export function QueueList({ items, selectedId, onSelect, filters, onFiltersChange }: QueueListProps) {
  const filteredItems = items.filter(item => {
    if (filters.type !== 'all' && item.type !== filters.type) return false;

    // Label filter only applies to issues (discussions don't have labels)
    if (filters.hasLabels === 'labeled' && item.type === 'issue' && item.labels.length === 0) return false;
    if (filters.hasLabels === 'unlabeled' && item.type === 'issue' && item.labels.length > 0) return false;

    if (filters.age === 'fresh' && item.isStale) return false;
    if (filters.age === 'stale' && !item.isStale) return false;
    if (filters.searchQuery && !item.title.toLowerCase().includes(filters.searchQuery.toLowerCase())) return false;
    return true;
  });

  return (
    <div className="flex flex-col h-full">
      {/* Filter bar */}
      <div className="p-3 border-b border-gray-800 space-y-2">
        <input
          type="text"
          placeholder="Search issues..."
          value={filters.searchQuery}
          onChange={(e) => onFiltersChange({ ...filters, searchQuery: e.target.value })}
          className="w-full px-3 py-1.5 bg-[#0d1117] border border-gray-700 rounded text-white text-sm placeholder-gray-500 focus:outline-none focus:border-blue-500"
        />
        <div className="flex gap-2 flex-wrap">
          <FilterChip
            label="All"
            active={filters.type === 'all'}
            onClick={() => onFiltersChange({ ...filters, type: 'all' })}
          />
          <FilterChip
            label="Issues"
            active={filters.type === 'issue'}
            onClick={() => onFiltersChange({ ...filters, type: 'issue' })}
          />
          <FilterChip
            label="Discussions"
            active={filters.type === 'discussion'}
            onClick={() => onFiltersChange({ ...filters, type: 'discussion' })}
          />
          <span className="mx-1 border-l border-gray-700" />
          <FilterChip
            label="Unlabeled Issues"
            active={filters.hasLabels === 'unlabeled'}
            onClick={() => onFiltersChange({ ...filters, hasLabels: filters.hasLabels === 'unlabeled' ? 'all' : 'unlabeled' })}
          />
          <FilterChip
            label="Stale"
            active={filters.age === 'stale'}
            onClick={() => onFiltersChange({ ...filters, age: filters.age === 'stale' ? 'all' : 'stale' })}
          />
        </div>
      </div>

      {/* Item list */}
      <div className="flex-1 overflow-y-auto">
        {filteredItems.length === 0 ? (
          <div className="p-8 text-center text-gray-500">
            {items.length === 0 ? 'No items in queue' : 'No items match filters'}
          </div>
        ) : (
          filteredItems.map(item => (
            <QueueItemRow
              key={item.id}
              item={item}
              isSelected={item.id === selectedId}
              onClick={() => onSelect(item)}
            />
          ))
        )}
      </div>

      {/* Count footer */}
      <div className="p-2 border-t border-gray-800 text-xs text-gray-500 text-center">
        Showing {filteredItems.length} of {items.length} items
      </div>
    </div>
  );
}

function FilterChip({ label, active, onClick }: { label: string; active: boolean; onClick: () => void }) {
  return (
    <button
      onClick={onClick}
      className={`px-2 py-0.5 text-xs rounded-full transition-colors ${
        active
          ? 'bg-blue-600 text-white'
          : 'bg-gray-800 text-gray-400 hover:bg-gray-700'
      }`}
    >
      {label}
    </button>
  );
}

function QueueItemRow({ item, isSelected, onClick }: { item: QueueItem; isSelected: boolean; onClick: () => void }) {
  const typeIcon = item.type === 'issue' ? '‚óè' : 'üí¨';

  return (
    <button
      onClick={onClick}
      className={`w-full p-3 text-left border-b border-gray-800 hover:bg-gray-800/50 transition-colors ${
        isSelected ? 'bg-gray-800 border-l-2 border-l-blue-500' : ''
      }`}
    >
      <div className="flex items-start gap-2">
        <span className={`text-sm ${item.type === 'issue' ? 'text-green-400' : 'text-purple-400'}`}>
          {typeIcon}
        </span>
        <div className="flex-1 min-w-0">
          <div className="flex items-center gap-2">
            <span className="text-gray-500 text-sm">#{item.number}</span>
            <span className="text-white font-medium truncate">{item.title}</span>
          </div>
          <div className="flex items-center gap-2 mt-1 text-xs">
            <span className="text-gray-500">@{item.author}</span>
            <span className={`${item.isStale ? 'text-yellow-400' : 'text-gray-500'}`}>
              {item.ageInDays}d
            </span>
            {item.isStale && (
              <span className="px-1.5 py-0.5 bg-yellow-900/50 text-yellow-400 rounded text-xs">
                STALE
              </span>
            )}
          </div>
          {item.labels.length > 0 && (
            <div className="flex gap-1 mt-1 flex-wrap">
              {item.labels.slice(0, 3).map(label => (
                <span key={label} className="px-1.5 py-0.5 bg-gray-700 text-gray-300 rounded text-xs">
                  {label}
                </span>
              ))}
              {item.labels.length > 3 && (
                <span className="text-gray-500 text-xs">+{item.labels.length - 3}</span>
              )}
            </div>
          )}
        </div>
      </div>
    </button>
  );
}
```

#### 3. Create Side Panel Component
**File**: `src/components/SidePanel/SidePanel.tsx` (new file)

```typescript
import { QueueItem, ClaudeAnalysis } from '../../types/intake';
import { useItemDetails } from '../../hooks/useIntakeQueue';
import ReactMarkdown from 'react-markdown';

interface SidePanelProps {
  item: QueueItem | null;
  analysis: ClaudeAnalysis | null;
  onClose: () => void;
  onApplyLabel: (label: string) => void;
  onRequestAnalysis: () => void;
}

export function SidePanel({ item, analysis, onClose, onApplyLabel, onRequestAnalysis }: SidePanelProps) {
  // Fetch full details including body when item is selected
  const { body, isLoading: bodyLoading, error: bodyError } = useItemDetails(item);
  if (!item) {
    return (
      <div className="h-full flex items-center justify-center text-gray-500">
        <div className="text-center">
          <p className="text-lg">Select an item to view details</p>
          <p className="text-sm mt-1">Click on any issue or discussion in the queue</p>
        </div>
      </div>
    );
  }

  return (
    <div className="h-full flex flex-col">
      {/* Header */}
      <div className="p-4 border-b border-gray-800 flex items-start justify-between">
        <div>
          <div className="flex items-center gap-2">
            <span className={`text-sm ${item.type === 'issue' ? 'text-green-400' : 'text-purple-400'}`}>
              {item.type === 'issue' ? 'Issue' : 'Discussion'}
            </span>
            <span className="text-gray-500">#{item.number}</span>
            {item.isStale && (
              <span className="px-1.5 py-0.5 bg-yellow-900/50 text-yellow-400 rounded text-xs">
                STALE
              </span>
            )}
          </div>
          <h2 className="text-lg font-medium text-white mt-1">{item.title}</h2>
          <div className="text-sm text-gray-400 mt-1">
            @{item.author} ¬∑ {item.ageInDays} days ago
          </div>
        </div>
        <div className="flex items-center gap-2">
          <a
            href={item.url}
            target="_blank"
            rel="noopener noreferrer"
            className="p-2 text-gray-400 hover:text-white hover:bg-gray-800 rounded-lg transition-colors"
            title="Open in GitHub"
          >
            <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
              <path d="M12 0C5.37 0 0 5.37 0 12c0 5.31 3.435 9.795 8.205 11.385.6.105.825-.255.825-.57 0-.285-.015-1.23-.015-2.235-3.015.555-3.795-.735-4.035-1.41-.135-.345-.72-1.41-1.23-1.695-.42-.225-1.02-.78-.015-.795.945-.015 1.62.87 1.845 1.23 1.08 1.815 2.805 1.305 3.495.99.105-.78.42-1.305.765-1.605-2.67-.3-5.46-1.335-5.46-5.925 0-1.305.465-2.385 1.23-3.225-.12-.3-.54-1.53.12-3.18 0 0 1.005-.315 3.3 1.23.96-.27 1.98-.405 3-.405s2.04.135 3 .405c2.295-1.56 3.3-1.23 3.3-1.23.66 1.65.24 2.88.12 3.18.765.84 1.23 1.905 1.23 3.225 0 4.605-2.805 5.625-5.475 5.925.435.375.81 1.095.81 2.22 0 1.605-.015 2.895-.015 3.3 0 .315.225.69.825.57A12.02 12.02 0 0024 12c0-6.63-5.37-12-12-12z"/>
            </svg>
          </a>
          <button
            onClick={onClose}
            className="p-2 text-gray-400 hover:text-white hover:bg-gray-800 rounded-lg transition-colors"
          >
            <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>
      </div>

      {/* Content */}
      <div className="flex-1 overflow-y-auto">
        {/* Labels */}
        {item.labels.length > 0 && (
          <div className="p-4 border-b border-gray-800">
            <h3 className="text-sm font-medium text-gray-400 mb-2">Labels</h3>
            <div className="flex gap-1 flex-wrap">
              {item.labels.map(label => (
                <span key={label} className="px-2 py-1 bg-gray-700 text-gray-300 rounded text-sm">
                  {label}
                </span>
              ))}
            </div>
          </div>
        )}

        {/* Body */}
        <div className="p-4 border-b border-gray-800">
          <h3 className="text-sm font-medium text-gray-400 mb-2">Description</h3>
          {bodyLoading ? (
            <div className="flex items-center gap-2 text-gray-400">
              <svg className="animate-spin h-4 w-4" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" fill="none"/>
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"/>
              </svg>
              <span>Loading description...</span>
            </div>
          ) : bodyError ? (
            <div className="text-red-400 text-sm">Failed to load description: {bodyError}</div>
          ) : (
            <div className="prose prose-invert prose-sm max-w-none">
              <ReactMarkdown>{body || '*No description provided*'}</ReactMarkdown>
            </div>
          )}
        </div>

        {/* Claude Analysis Section */}
        <div className="p-4">
          <div className="flex items-center justify-between mb-3">
            <h3 className="text-sm font-medium text-gray-400">Claude Analysis</h3>
            {!analysis && (
              <button
                onClick={onRequestAnalysis}
                className="px-3 py-1 bg-blue-600 hover:bg-blue-700 text-white text-sm rounded transition-colors"
              >
                Analyze
              </button>
            )}
          </div>

          {analysis?.isLoading ? (
            <div className="flex items-center gap-2 text-gray-400">
              <svg className="animate-spin h-4 w-4" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" fill="none"/>
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"/>
              </svg>
              <span>Analyzing...</span>
            </div>
          ) : analysis?.error ? (
            <div className="text-red-400 text-sm">{analysis.error}</div>
          ) : analysis ? (
            <div className="space-y-4">
              {/* Summary */}
              <div>
                <h4 className="text-xs font-medium text-gray-500 uppercase mb-1">Summary</h4>
                <p className="text-gray-300 text-sm">{analysis.summary}</p>
              </div>

              {/* Suggested Labels */}
              {analysis.suggestedLabels.length > 0 && (
                <div>
                  <h4 className="text-xs font-medium text-gray-500 uppercase mb-1">Suggested Labels</h4>
                  <div className="flex gap-2 flex-wrap">
                    {analysis.suggestedLabels.map(label => (
                      <button
                        key={label}
                        onClick={() => onApplyLabel(label)}
                        className="px-2 py-1 bg-blue-900/50 text-blue-400 hover:bg-blue-800 rounded text-sm transition-colors"
                      >
                        + {label}
                      </button>
                    ))}
                  </div>
                </div>
              )}

              {/* Duplicates */}
              {analysis.duplicates.length > 0 && (
                <div>
                  <h4 className="text-xs font-medium text-gray-500 uppercase mb-1">Potential Duplicates</h4>
                  <div className="space-y-1">
                    {analysis.duplicates.map(dup => (
                      <a
                        key={dup.number}
                        href={dup.url}
                        target="_blank"
                        rel="noopener noreferrer"
                        className="block p-2 bg-gray-800 hover:bg-gray-700 rounded text-sm transition-colors"
                      >
                        <span className="text-gray-500">#{dup.number}</span>{' '}
                        <span className="text-gray-300">{dup.title}</span>
                        {dup.similarity > 0 && (
                          <span className="text-gray-500 ml-2">({Math.round(dup.similarity * 100)}% similar)</span>
                        )}
                      </a>
                    ))}
                  </div>
                </div>
              )}

              {/* Draft Response */}
              {analysis.draftResponse && (
                <div>
                  <h4 className="text-xs font-medium text-gray-500 uppercase mb-1">Draft Response</h4>
                  <div className="p-3 bg-gray-800 rounded text-sm text-gray-300 whitespace-pre-wrap">
                    {analysis.draftResponse}
                  </div>
                  <button
                    onClick={() => navigator.clipboard.writeText(analysis.draftResponse!)}
                    className="mt-2 px-3 py-1 bg-gray-700 hover:bg-gray-600 text-white text-sm rounded transition-colors"
                  >
                    Copy to Clipboard
                  </button>
                </div>
              )}
            </div>
          ) : (
            <p className="text-gray-500 text-sm">
              Click "Analyze" to get AI-powered insights, label suggestions, and duplicate detection.
            </p>
          )}
        </div>
      </div>
    </div>
  );
}
```

#### 4. Update Main App Component
**File**: `src/App.tsx`
**Changes**: Complete rewrite for command center layout

```typescript
import { useState } from 'react';
import { ProgressHeader } from './components/ProgressHeader/ProgressHeader';
import { QueueList, QueueFilters } from './components/QueueList/QueueList';
import { SidePanel } from './components/SidePanel/SidePanel';
import { useIntakeQueue } from './hooks/useIntakeQueue';
import { QueueItem, ClaudeAnalysis } from './types/intake';

const DEFAULT_FILTERS: QueueFilters = {
  type: 'all',
  hasLabels: 'all',
  age: 'all',
  searchQuery: '',
};

function App() {
  const queue = useIntakeQueue();
  const [selectedItem, setSelectedItem] = useState<QueueItem | null>(null);
  const [analysis, setAnalysis] = useState<ClaudeAnalysis | null>(null);
  const [filters, setFilters] = useState<QueueFilters>(DEFAULT_FILTERS);

  const handleSelectItem = (item: QueueItem) => {
    setSelectedItem(item);
    setAnalysis(null); // Clear previous analysis
  };

  const handleClosePanel = () => {
    setSelectedItem(null);
    setAnalysis(null);
  };

  const handleRequestAnalysis = async () => {
    if (!selectedItem) return;

    setAnalysis({ suggestedLabels: [], duplicates: [], summary: '', isLoading: true });

    // TODO: Implement in Phase 4
    // For now, simulate loading
    setTimeout(() => {
      setAnalysis({
        suggestedLabels: ['area:editor', 'type:bug'],
        duplicates: [],
        summary: 'This appears to be a bug report about...',
        isLoading: false,
      });
    }, 1000);
  };

  const handleApplyLabel = async (label: string) => {
    if (!selectedItem) return;

    try {
      const response = await fetch(`/api/issues/${selectedItem.number}/labels`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ label, action: 'add' }),
      });

      if (response.ok) {
        // Refresh to show updated labels
        queue.refresh();
      }
    } catch (error) {
      console.error('Failed to apply label:', error);
    }
  };

  // Calculate completed count (items with status labels or triaged)
  const completedCount = queue.items.filter(item =>
    item.labels.some(l => l.startsWith('status:'))
  ).length;

  return (
    <div className="h-screen flex flex-col bg-[#0d1117]">
      <ProgressHeader
        totalCount={queue.totalCount}
        completedCount={completedCount}
        staleCount={queue.staleCount}
        isLoading={queue.isLoading}
        lastUpdated={queue.fetchedAt}
        onRefresh={queue.refresh}
      />

      <main className="flex-1 flex overflow-hidden">
        {/* Queue list */}
        <div className="w-1/2 lg:w-3/5 border-r border-gray-800 overflow-hidden">
          <QueueList
            items={queue.items}
            selectedId={selectedItem?.id ?? null}
            onSelect={handleSelectItem}
            filters={filters}
            onFiltersChange={setFilters}
          />
        </div>

        {/* Side panel */}
        <div className="w-1/2 lg:w-2/5 bg-[#161b22] overflow-hidden">
          <SidePanel
            item={selectedItem}
            analysis={analysis}
            onClose={handleClosePanel}
            onApplyLabel={handleApplyLabel}
            onRequestAnalysis={handleRequestAnalysis}
          />
        </div>
      </main>

      {/* Error toast */}
      {queue.error && (
        <div className="fixed bottom-4 right-4 bg-red-900/90 text-red-200 px-4 py-2 rounded-lg shadow-lg">
          {queue.error}
        </div>
      )}
    </div>
  );
}

export default App;
```

### Success Criteria:

#### Automated Verification:
- [ ] TypeScript compiles without errors: `npx tsc --noEmit`
- [ ] Frontend builds successfully: `npm run build`
- [ ] Dev server starts: `npm run dev`

#### Manual Verification:
- [ ] Page loads with queue data visible immediately
- [ ] Progress header shows correct counts
- [ ] Queue list displays all issues and discussions unified
- [ ] Stale items (14+ days) show yellow indicator
- [ ] Filter chips work correctly (type, unlabeled, stale)
- [ ] Search filters the list in real-time
- [ ] Clicking an item opens side panel with details
- [ ] Side panel shows full issue/discussion body
- [ ] "Open in GitHub" link works
- [ ] Close button dismisses side panel

**Implementation Note**: After completing this phase, pause for manual testing of the new layout before proceeding to Phase 3.

---

## Phase 3: Quick Actions (Labels & Status)

### Overview
Implement one-click label application and status updates from the side panel.

### Changes Required:

#### 1. Create Label Picker Component
**File**: `src/components/LabelPicker/LabelPicker.tsx` (new file)

```typescript
import { useState, useEffect } from 'react';

interface LabelPickerProps {
  currentLabels: string[];
  onApply: (label: string) => void;
  onRemove: (label: string) => void;
}

// Common labels for the Positron repo
const AREA_LABELS = [
  'area:editor', 'area:console', 'area:variables', 'area:plots',
  'area:connections', 'area:help', 'area:data-explorer', 'area:notebooks',
  'area:extensions', 'area:r', 'area:python', 'area:infrastructure',
];

const TYPE_LABELS = ['type:bug', 'type:enhancement', 'type:question', 'type:docs'];

const STATUS_LABELS = ['status:triaged', 'status:needs-info', 'status:blocked'];

export function LabelPicker({ currentLabels, onApply, onRemove }: LabelPickerProps) {
  const [searchQuery, setSearchQuery] = useState('');
  const [isExpanded, setIsExpanded] = useState(false);

  const allLabels = [...AREA_LABELS, ...TYPE_LABELS, ...STATUS_LABELS];
  const availableLabels = allLabels.filter(l => !currentLabels.includes(l));

  const filteredLabels = searchQuery
    ? availableLabels.filter(l => l.toLowerCase().includes(searchQuery.toLowerCase()))
    : availableLabels;

  return (
    <div className="space-y-3">
      {/* Current labels */}
      {currentLabels.length > 0 && (
        <div>
          <h4 className="text-xs font-medium text-gray-500 uppercase mb-1">Current Labels</h4>
          <div className="flex gap-1 flex-wrap">
            {currentLabels.map(label => (
              <span
                key={label}
                className="group px-2 py-1 bg-gray-700 text-gray-300 rounded text-sm flex items-center gap-1"
              >
                {label}
                <button
                  onClick={() => onRemove(label)}
                  className="opacity-0 group-hover:opacity-100 text-gray-400 hover:text-red-400 transition-opacity"
                >
                  √ó
                </button>
              </span>
            ))}
          </div>
        </div>
      )}

      {/* Add label */}
      <div>
        <button
          onClick={() => setIsExpanded(!isExpanded)}
          className="text-sm text-blue-400 hover:text-blue-300"
        >
          {isExpanded ? '‚àí Hide label picker' : '+ Add label'}
        </button>

        {isExpanded && (
          <div className="mt-2 p-3 bg-gray-800 rounded-lg">
            <input
              type="text"
              placeholder="Search labels..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              className="w-full px-2 py-1 bg-gray-900 border border-gray-700 rounded text-white text-sm mb-2 focus:outline-none focus:border-blue-500"
            />

            {/* Quick access sections */}
            {!searchQuery && (
              <div className="space-y-2">
                <LabelSection title="Area" labels={AREA_LABELS} currentLabels={currentLabels} onApply={onApply} />
                <LabelSection title="Type" labels={TYPE_LABELS} currentLabels={currentLabels} onApply={onApply} />
                <LabelSection title="Status" labels={STATUS_LABELS} currentLabels={currentLabels} onApply={onApply} />
              </div>
            )}

            {/* Search results */}
            {searchQuery && (
              <div className="flex gap-1 flex-wrap">
                {filteredLabels.length === 0 ? (
                  <span className="text-gray-500 text-sm">No matching labels</span>
                ) : (
                  filteredLabels.map(label => (
                    <button
                      key={label}
                      onClick={() => {
                        onApply(label);
                        setSearchQuery('');
                      }}
                      className="px-2 py-1 bg-blue-900/50 text-blue-400 hover:bg-blue-800 rounded text-sm transition-colors"
                    >
                      + {label}
                    </button>
                  ))
                )}
              </div>
            )}
          </div>
        )}
      </div>
    </div>
  );
}

function LabelSection({
  title,
  labels,
  currentLabels,
  onApply
}: {
  title: string;
  labels: string[];
  currentLabels: string[];
  onApply: (label: string) => void;
}) {
  const available = labels.filter(l => !currentLabels.includes(l));
  if (available.length === 0) return null;

  return (
    <div>
      <h5 className="text-xs text-gray-500 mb-1">{title}</h5>
      <div className="flex gap-1 flex-wrap">
        {available.map(label => (
          <button
            key={label}
            onClick={() => onApply(label)}
            className="px-2 py-0.5 bg-gray-700 text-gray-300 hover:bg-gray-600 rounded text-xs transition-colors"
          >
            {label.replace(/^(area|type|status):/, '')}
          </button>
        ))}
      </div>
    </div>
  );
}
```

#### 2. Add GitHub Label API Endpoints
**File**: `server/github.ts`
**Changes**: Add function to fetch available labels

```typescript
// Add to existing file

export async function fetchRepoLabels(): Promise<string[]> {
  const { stdout } = await execAsync(
    `gh label list --repo ${REPO} --json name --limit 200`
  );
  const labels = JSON.parse(stdout || '[]');
  return labels.map((l: { name: string }) => l.name);
}
```

#### 3. Add Labels API Endpoint
**File**: `server/index.ts`
**Changes**: Add endpoint for fetching available labels

```typescript
// Add after other endpoints

app.get('/api/labels', async (req, res) => {
  try {
    const labels = await fetchRepoLabels();
    res.json({ labels });
  } catch (error) {
    console.error('Failed to fetch labels:', error);
    res.status(500).json({ error: 'Failed to fetch labels' });
  }
});
```

#### 4. Update Side Panel with Label Picker
**File**: `src/components/SidePanel/SidePanel.tsx`
**Changes**: Integrate LabelPicker component

```typescript
// Add import at top
import { LabelPicker } from '../LabelPicker/LabelPicker';

// Update SidePanelProps interface
interface SidePanelProps {
  item: QueueItem | null;
  analysis: ClaudeAnalysis | null;
  onClose: () => void;
  onApplyLabel: (label: string) => void;
  onRemoveLabel: (label: string) => void;  // Add this
  onRequestAnalysis: () => void;
}

// Replace the Labels section in the component with:
{/* Labels section - always show for issues */}
{item.type === 'issue' && (
  <div className="p-4 border-b border-gray-800">
    <h3 className="text-sm font-medium text-gray-400 mb-2">Labels</h3>
    <LabelPicker
      currentLabels={item.labels}
      onApply={onApplyLabel}
      onRemove={onRemoveLabel}
    />
  </div>
)}
```

#### 5. Update App to Handle Label Removal
**File**: `src/App.tsx`
**Changes**: Add handleRemoveLabel function

```typescript
// Add this function alongside handleApplyLabel
const handleRemoveLabel = async (label: string) => {
  if (!selectedItem) return;

  try {
    const response = await fetch(`/api/issues/${selectedItem.number}/labels`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ label, action: 'remove' }),
    });

    if (response.ok) {
      queue.refresh();
    }
  } catch (error) {
    console.error('Failed to remove label:', error);
  }
};

// Update SidePanel props
<SidePanel
  item={selectedItem}
  analysis={analysis}
  onClose={handleClosePanel}
  onApplyLabel={handleApplyLabel}
  onRemoveLabel={handleRemoveLabel}  // Add this
  onRequestAnalysis={handleRequestAnalysis}
/>
```

### Success Criteria:

#### Automated Verification:
- [ ] TypeScript compiles without errors: `npx tsc --noEmit`
- [ ] Frontend builds successfully: `npm run build`
- [ ] Labels endpoint returns data: `curl http://localhost:3001/api/labels`

#### Manual Verification:
- [ ] Label picker expands when "Add label" clicked
- [ ] Labels grouped by type (area, type, status)
- [ ] Clicking label adds it to issue via GitHub API
- [ ] Label appears in current labels list after refresh
- [ ] Remove button (√ó) appears on hover over current labels
- [ ] Clicking remove button removes label via GitHub API
- [ ] Search filters available labels correctly

**Implementation Note**: After completing this phase, pause for manual testing of label management before proceeding to Phase 4.

---

## Phase 4: Claude Per-Item Analysis

### Overview
Integrate Claude for on-demand analysis when a user selects an item. Claude provides label suggestions, duplicate detection, summary, and draft responses.

### Changes Required:

#### 1. Create Analysis Prompt
**File**: `server/prompts/analysis.ts` (new file)

```typescript
export const ANALYSIS_SYSTEM_PROMPT = `You are an expert at triaging GitHub issues for the Positron IDE project (a next-generation data science IDE built on VS Code).

Your job is to analyze issues and provide structured assistance to intake triagers.

Available area labels:
- area:editor - Core text editing, Monaco editor issues
- area:console - Interactive console (R, Python REPL)
- area:variables - Variables pane, object inspection
- area:plots - Plot viewer, visualization
- area:connections - Database connections, remote connections
- area:help - Help pane, documentation viewer
- area:data-explorer - Data frame viewer, table exploration
- area:notebooks - Jupyter notebook support
- area:extensions - Extension compatibility, marketplace
- area:r - R language support, R interpreter
- area:python - Python language support, Python interpreter
- area:infrastructure - Build, CI/CD, installation, packaging

Type labels:
- type:bug - Something broken or not working
- type:enhancement - New feature or improvement
- type:question - User asking for help
- type:docs - Documentation issue

When analyzing, consider:
1. What area of Positron does this affect?
2. Is this a bug, feature request, question, or docs issue?
3. Have we seen similar issues before?
4. What information might we need from the reporter?`;

export function buildAnalysisPrompt(issue: {
  number: number;
  title: string;
  body: string;
  labels: string[];
}): string {
  return `Analyze this GitHub issue and provide structured analysis:

## Issue #${issue.number}: ${issue.title}

${issue.body || '*No description provided*'}

Current labels: ${issue.labels.length > 0 ? issue.labels.join(', ') : 'None'}

Respond with a JSON object in this exact format:
\`\`\`json
{
  "summary": "1-2 sentence summary of what this issue is about",
  "suggestedLabels": ["label1", "label2"],
  "duplicateSearchTerms": ["term1", "term2"],
  "needsInfo": true/false,
  "draftResponse": "optional draft response if reporter needs info or acknowledgment"
}
\`\`\`

Only suggest labels that are not already applied.
For duplicateSearchTerms, provide 2-3 search terms we could use to find similar issues.
Set needsInfo to true if the issue lacks reproduction steps, version info, or other critical details.
Only include draftResponse if we need to ask for info or provide a helpful acknowledgment.`;
}
```

#### 2. Create Analysis API Endpoint
**File**: `server/index.ts`
**Changes**: Add analysis endpoint using Claude

```typescript
// Add imports at top (note the .js extension for ESM)
import { ANALYSIS_SYSTEM_PROMPT, buildAnalysisPrompt } from './prompts/analysis.js';
import { query } from '@anthropic-ai/claude-code';

// Add endpoint
app.post('/api/issues/:number/analyze', async (req, res) => {
  const { number } = req.params;
  const { title, body, labels } = req.body;

  try {
    const prompt = buildAnalysisPrompt({
      number: parseInt(number),
      title,
      body,
      labels
    });

    let fullResponse = '';

    for await (const message of query({
      prompt,
      options: {
        allowedTools: [], // No tools needed for analysis
        appendSystemPrompt: ANALYSIS_SYSTEM_PROMPT,
        maxTurns: 1,
      },
    })) {
      if (message.type === 'assistant') {
        for (const block of message.message.content) {
          if (block.type === 'text') {
            fullResponse += block.text;
          }
        }
      }
    }

    // Extract JSON from response
    const jsonMatch = fullResponse.match(/```json\s*([\s\S]*?)```/);
    if (jsonMatch) {
      const analysis = JSON.parse(jsonMatch[1]);
      res.json(analysis);
    } else {
      res.status(500).json({ error: 'Failed to parse analysis response' });
    }
  } catch (error) {
    console.error('Analysis failed:', error);
    res.status(500).json({ error: 'Analysis failed' });
  }
});

// Add duplicate search endpoint
app.post('/api/issues/search-duplicates', async (req, res) => {
  const { searchTerms, excludeNumber } = req.body;

  try {
    const searchQuery = searchTerms.join(' OR ');
    const result = await execGitHub([
      'issue', 'list',
      '--repo', REPO,
      '--search', searchQuery,
      '--json', 'number,title,state,url',
      '--limit', '10'
    ]);

    const issues = JSON.parse(result || '[]')
      .filter((i: any) => i.number !== excludeNumber)
      .slice(0, 5)
      .map((i: any) => ({
        number: i.number,
        title: i.title,
        url: i.url,
        state: i.state
      }));

    res.json({ duplicates: issues });
  } catch (error) {
    console.error('Duplicate search failed:', error);
    res.status(500).json({ error: 'Duplicate search failed' });
  }
});
```

#### 3. Create Analysis Hook
**File**: `src/hooks/useAnalysis.ts` (new file)

```typescript
import { useState, useCallback } from 'react';
import { ClaudeAnalysis, QueueItem } from '../types/intake';

export function useAnalysis() {
  const [analysis, setAnalysis] = useState<ClaudeAnalysis | null>(null);

  const analyzeItem = useCallback(async (item: QueueItem) => {
    setAnalysis({
      suggestedLabels: [],
      duplicates: [],
      summary: '',
      isLoading: true
    });

    try {
      // Get Claude's analysis
      const analysisResponse = await fetch(`/api/issues/${item.number}/analyze`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          title: item.title,
          body: item.body,
          labels: item.labels,
        }),
      });

      if (!analysisResponse.ok) {
        throw new Error('Analysis request failed');
      }

      const analysisData = await analysisResponse.json();

      // Search for duplicates using Claude's suggested terms
      let duplicates: ClaudeAnalysis['duplicates'] = [];
      if (analysisData.duplicateSearchTerms?.length > 0) {
        const dupResponse = await fetch('/api/issues/search-duplicates', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            searchTerms: analysisData.duplicateSearchTerms,
            excludeNumber: item.number,
          }),
        });

        if (dupResponse.ok) {
          const dupData = await dupResponse.json();
          duplicates = dupData.duplicates.map((d: any) => ({
            number: d.number,
            title: d.title,
            url: d.url,
            similarity: 0.7, // Placeholder - could calculate actual similarity
          }));
        }
      }

      setAnalysis({
        suggestedLabels: analysisData.suggestedLabels || [],
        duplicates,
        summary: analysisData.summary || '',
        draftResponse: analysisData.draftResponse,
        isLoading: false,
      });
    } catch (error) {
      setAnalysis({
        suggestedLabels: [],
        duplicates: [],
        summary: '',
        isLoading: false,
        error: error instanceof Error ? error.message : 'Analysis failed',
      });
    }
  }, []);

  const clearAnalysis = useCallback(() => {
    setAnalysis(null);
  }, []);

  return { analysis, analyzeItem, clearAnalysis };
}
```

#### 4. Update App to Use Analysis Hook
**File**: `src/App.tsx`
**Changes**: Replace manual analysis state with hook

```typescript
// Replace analysis state and handleRequestAnalysis with:
import { useAnalysis } from './hooks/useAnalysis';

// In the component:
const { analysis, analyzeItem, clearAnalysis } = useAnalysis();

const handleSelectItem = (item: QueueItem) => {
  setSelectedItem(item);
  clearAnalysis(); // Clear previous analysis
};

const handleRequestAnalysis = () => {
  if (selectedItem) {
    analyzeItem(selectedItem);
  }
};
```

### Success Criteria:

#### Automated Verification:
- [ ] TypeScript compiles without errors: `npx tsc --noEmit`
- [ ] Frontend builds successfully: `npm run build`
- [ ] Analysis endpoint responds: `curl -X POST http://localhost:3001/api/issues/123/analyze -H "Content-Type: application/json" -d '{"title":"Test","body":"Test body","labels":[]}'`

#### Manual Verification:
- [ ] Clicking "Analyze" in side panel triggers Claude analysis
- [ ] Loading spinner appears during analysis
- [ ] Summary appears after analysis completes
- [ ] Suggested labels are displayed and clickable
- [ ] Clicking suggested label applies it to the issue
- [ ] Duplicate issues are searched and displayed
- [ ] Draft response appears when Claude suggests one
- [ ] "Copy to Clipboard" button works for draft response
- [ ] Error handling works when analysis fails

**Implementation Note**: After completing this phase, pause for manual testing of Claude analysis before proceeding to Phase 5.

---

## Phase 5: Polish & Cleanup

### Overview
Remove legacy chat interface, clean up unused code, add final UX polish.

### Changes Required:

#### 1. Remove Legacy Components
**Files to delete**:
- `src/components/ChatInterface/ChatInterface.tsx`
- `src/components/StreamingMessage/StreamingMessage.tsx`
- `src/components/QuickActions/QuickActions.tsx`
- `src/hooks/useAgentChat.ts`
- `src/hooks/useIntakeData.ts`

#### 2. Clean Up Types
**File**: `src/types/intake.ts`
**Changes**: Remove SDK message types that are no longer needed

Keep:
- `QueueItem`
- `ClaudeAnalysis`
- `Issue` (may still be useful)
- `Discussion` (may still be useful)

Remove (unless still needed elsewhere):
- `SDKAssistantMessage`
- `SDKResultMessage`
- `SDKSystemMessage`
- `SDKStreamEvent`
- `SDKUserMessage`
- `ErrorMessage`
- `SDKMessage`
- `ChatMessage`
- `IntakeData`

#### 3. Update Server - Remove WebSocket
**File**: `server/index.ts`
**Changes**: Remove WebSocket handlers if no longer needed

If WebSocket is not used by any remaining feature, remove:
- WebSocket server setup
- Client state management
- Message handlers (catch_up, follow_up, quick_action)
- Keep only REST API endpoints

#### 4. Add Keyboard Navigation
**File**: `src/App.tsx`
**Changes**: Add keyboard shortcuts for power users

```typescript
// Add useEffect for keyboard shortcuts
useEffect(() => {
  const handleKeyDown = (e: KeyboardEvent) => {
    // Don't trigger if typing in input
    if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) {
      return;
    }

    const items = queue.items;
    const currentIndex = selectedItem ? items.findIndex(i => i.id === selectedItem.id) : -1;

    switch (e.key) {
      case 'j': // Next item
      case 'ArrowDown':
        if (currentIndex < items.length - 1) {
          handleSelectItem(items[currentIndex + 1]);
        } else if (currentIndex === -1 && items.length > 0) {
          handleSelectItem(items[0]);
        }
        break;
      case 'k': // Previous item
      case 'ArrowUp':
        if (currentIndex > 0) {
          handleSelectItem(items[currentIndex - 1]);
        }
        break;
      case 'Escape':
        handleClosePanel();
        break;
      case 'a':
        if (selectedItem && !analysis?.isLoading) {
          handleRequestAnalysis();
        }
        break;
      case 'o':
        if (selectedItem) {
          window.open(selectedItem.url, '_blank');
        }
        break;
      case 'r':
        if (!queue.isLoading) {
          queue.refresh();
        }
        break;
    }
  };

  window.addEventListener('keydown', handleKeyDown);
  return () => window.removeEventListener('keydown', handleKeyDown);
}, [queue.items, selectedItem, analysis, queue.isLoading]);
```

#### 5. Add Help Modal with Keyboard Shortcuts
**File**: `src/components/HelpModal/HelpModal.tsx` (new file)

```typescript
interface HelpModalProps {
  isOpen: boolean;
  onClose: () => void;
}

export function HelpModal({ isOpen, onClose }: HelpModalProps) {
  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50" onClick={onClose}>
      <div className="bg-[#161b22] rounded-lg border border-gray-700 p-6 max-w-md" onClick={e => e.stopPropagation()}>
        <h2 className="text-lg font-semibold text-white mb-4">Keyboard Shortcuts</h2>

        <div className="space-y-3 text-sm">
          <ShortcutRow keys={['j', '‚Üì']} description="Next item" />
          <ShortcutRow keys={['k', '‚Üë']} description="Previous item" />
          <ShortcutRow keys={['a']} description="Analyze selected item" />
          <ShortcutRow keys={['o']} description="Open in GitHub" />
          <ShortcutRow keys={['r']} description="Refresh queue" />
          <ShortcutRow keys={['Esc']} description="Close side panel" />
          <ShortcutRow keys={['?']} description="Show this help" />
        </div>

        <button
          onClick={onClose}
          className="mt-6 w-full py-2 bg-gray-700 hover:bg-gray-600 text-white rounded transition-colors"
        >
          Close
        </button>
      </div>
    </div>
  );
}

function ShortcutRow({ keys, description }: { keys: string[]; description: string }) {
  return (
    <div className="flex items-center justify-between">
      <span className="text-gray-400">{description}</span>
      <div className="flex gap-1">
        {keys.map((key, i) => (
          <span key={i}>
            <kbd className="px-2 py-0.5 bg-gray-800 border border-gray-600 rounded text-gray-300 font-mono text-xs">
              {key}
            </kbd>
            {i < keys.length - 1 && <span className="text-gray-500 mx-1">/</span>}
          </span>
        ))}
      </div>
    </div>
  );
}
```

#### 6. Update Header with Help Button
**File**: `src/components/ProgressHeader/ProgressHeader.tsx`
**Changes**: Add help button (?) that opens help modal

```typescript
// Add to props
onHelpClick: () => void;

// Add button before refresh button
<button
  onClick={onHelpClick}
  className="p-2 text-gray-400 hover:text-white hover:bg-gray-800 rounded-lg transition-colors"
  title="Keyboard shortcuts (?)"
>
  <span className="text-sm font-mono">?</span>
</button>
```

### Success Criteria:

#### Automated Verification:
- [ ] TypeScript compiles without errors: `npx tsc --noEmit`
- [ ] No unused imports warnings from linter
- [ ] Frontend builds successfully: `npm run build`
- [ ] Build size is smaller than before (removed unused code)

#### Manual Verification:
- [ ] Legacy chat interface is completely removed from UI
- [ ] Keyboard navigation works (j/k to navigate, a to analyze, etc.)
- [ ] Help modal opens with ? key
- [ ] All shortcuts work as documented
- [ ] No console errors during normal operation
- [ ] App feels responsive and polished

**Implementation Note**: This is the final phase. After completion, do a full end-to-end test of all functionality.

---

## Testing Strategy

### Unit Tests (Future Enhancement)
- `useIntakeQueue` hook: test filtering, sorting, age calculation
- `useAnalysis` hook: test API integration, error handling
- Component rendering with various data states

### Integration Tests
- API endpoints return correct data structures
- Label application persists to GitHub
- Claude analysis returns parseable JSON

### Manual Testing Steps

1. **Initial Load**
   - [ ] Open app, verify data loads in < 3 seconds
   - [ ] Count displayed matches GitHub's actual intake queue

2. **Queue Navigation**
   - [ ] Scroll through queue, verify all items visible
   - [ ] Filter by type, verify correct filtering
   - [ ] Filter by stale, verify 14+ day items shown
   - [ ] Search works and filters in real-time

3. **Item Details**
   - [ ] Click item, side panel opens with full details
   - [ ] Markdown renders correctly in body
   - [ ] "Open in GitHub" opens correct issue

4. **Label Management**
   - [ ] Add label, verify it appears on issue in GitHub
   - [ ] Remove label, verify removal in GitHub
   - [ ] Label picker shows correct available labels

5. **Claude Analysis**
   - [ ] Click Analyze, loading state appears
   - [ ] Analysis completes with suggestions
   - [ ] Click suggested label, applies correctly
   - [ ] Draft response can be copied

6. **Keyboard Shortcuts**
   - [ ] j/k navigate queue
   - [ ] a triggers analysis
   - [ ] o opens in GitHub
   - [ ] r refreshes queue
   - [ ] Esc closes panel
   - [ ] ? shows help

---

## Performance Considerations

- **Initial load**: Target < 2 seconds for queue list data (no bodies = fast)
- **Detail fetch**: Target < 1 second for individual item body
- **Filtering**: Client-side filtering should be instant (< 100ms)
- **Claude analysis**: Expected 3-10 seconds depending on issue complexity
- **Label operations**: Should complete in < 2 seconds
- **GraphQL queries**: Use pagination to avoid timeouts on large result sets
- **Memory**: Spawn instead of exec prevents buffer overflow on large outputs

## Migration Notes

No data migration required - the app fetches live data from GitHub on each load. Users can switch to 2.0 immediately after deployment.

## References

- Original requirements: `docs/REDESIGN_NOTES.md`
- Current implementation: `src/App.tsx`, `server/agent.ts`
- Similar patterns: Existing IssueQueue component for list rendering
